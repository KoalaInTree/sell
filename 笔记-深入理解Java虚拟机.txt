一、java虚拟机的参数设汇总
1.java堆的最大值 -Xmx
2.java堆的最小值 -Xms
3.在堆内存溢出时内存堆转储快照，用于分析：-XX:+HeapDumpOnOutOfMemoryError
4.栈容量：由-Xss参数设置
5.方法区容量： -XX:PermSize和-XX:MaxPermSize
6.垃圾回收：-Xnoclassgc控制，-verbose:class和-XX:+TraceClassLoading、-XX:+TraceClassUnLoading
查看类的加载和卸载信息
7.垃圾收集器参数:-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure
								-XX:ParallelGCThreads控制垃圾收集的线程数
8.Parallel Scavenge参数：-XX:MaxGCPauseMillis（最大垃圾收集停顿时间）和-XX:GCTimeRatio（吞吐量大小,0-100,垃圾收集时间/总时间的比例）
9.CMS收集器：-XX:CMSInitiatingOccupancyFraction 触发时老年代内存百分比的临界值
						-XX:+UseCMSCompactAtFullCollection 开关参数，gc后进行一次碎片整理
						-XX:+CMSFullGCBeforeCompaction 经过多少次不整理的full gc后，进行一次碎片整理
10.G1收集器："-XX:+UseG1GC"：指定使用G1收集器；
			      "-XX:InitiatingHeapOccupancyPercent"：当整个Java堆的占用率达到参数值时，开始并发标记阶段；默认为45；
			      "-XX:MaxGCPauseMillis"：为G1设置暂停时间目标，默认值为200毫秒；
 			     "-XX:G1HeapRegionSize"：设置每个Region大小，范围1MB到32MB；目标是在最小Java堆时可以拥有约2048个Region；
二、概述
1.线程运行时的数据区包括:方法区、堆、虚拟机栈、本地方法栈、程序计数器
	1.1程序计数器：
		1.线程私有
		2.当前线程要执行的字节码的行号。
		3.字节码解释器是改变计数器的值来控制线程执行顺序
		4.当执行native方法时，该值为空undefined
		5.唯一没有没有outofmemeryerror的区域
	1.2java虚拟机栈
		1.线程私有，生命周期与线程相同
		2.虚拟机栈描述的是内存模型，每个方法执行会创建栈帧。
	 *3.栈帧是一种数据结构，包括：局部变量表、操作栈、动态链接、方法出口等信息。
		4.每个方法的调用就对应着一个栈帧在虚拟机的入栈到出栈的过程。
	 *5.局部变量表存放着编译期可知的基本数据类型、对象引用和returnAddress(指向了一条字节码指令的地址)
			内存空间在编译期确定
		6.规范有两种异常状况：1.StackOverflowError和outofmemeryerror
	1.3本地方法栈
		1.线程私有
		2.与虚拟机栈相似
		3.为虚拟机执行本地方法服务
		4.规范有两种异常状况：1.StackOverflowError和outofmemeryerror
	1.4java堆
		1.线程共享内存
		2.在虚拟机启动时创建，用于存放对象实例以及数组
		3.随着JIT编译器的发展，不一定在堆分配内存。
		4.按不同维度可以分为新生代、老年代和Eden空间、From Survivor空间、To Survivor空间
		5.进一步的划分是为了更好的创建对象和回收内存
		6.outofmemeryerror异常
		7.物理上不连续的内存空间。
	1.5方法区
		1.线程共享的内存区域
		2.存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
		3.规范把方法区描述为堆的一个逻辑部分，但是它有一个别名叫Non-Heap
		4.别名永久代，因为gc分代收集也包括方法区，hotspot的做法。
		5.在此区域的垃圾收集比较少出现，主要是针对常量池的回收和对类型的卸载
		6.outofmemeryerror异常
	1.6运行时常量池
		1.是方法区的一部分。
		2.Class文件包括：类的版本、字段、方法、接口等描述信息、还有常量池，用于存放编译期生成的各种字面量
			和符号引用，将在类加载后存放到方法区的运行时常量池
		3.class文件的符号引用和翻译出来的直接引用也会存储在运行时常量池//todo 概念在第六章
		4.运行时常量池可以在运行期加入。比如String类的intern()方法
		5.outofmemeryerror异常
	1.7直接内存
		1.不是虚拟机运行时数据区的一部分，是因为NIO(New Input/Output)类，引入
			一种基于channel与buffer的I/O方法。直接分配堆外内存，在堆内的DirectByteBuffer对象
			作为这块内存的引用进行操作。
		2.outofmemeryerror异常
2.对象访问
	2.1.Object obj = new Object(); 类信息（对象类型，父类、实现的接口、方法等）存放在方法区的运行时常量池
	obj的reference放在虚拟机栈的局部变量表，对象存放在堆内存
	2.2.主流的访问方式：使用句柄和直接指针
			1.句柄访问方式：需要java堆划分一块句柄池。reference存的是对象的句柄地址，句柄中
				包含了对象实例数据和类型数据的具体地址信息
			2.直接指针访问方式：需要在堆对象中包含到方法区存储的对象类型数据的指针，
				reference直接存储对象地址
			3.不同方式的优劣：
				句柄访问在对象被移动（GC时会移动）无需修改reference的地址
				直接指针访问的优势在于速度快，少一次指针定位时间。 (Hotspot实现方式)
			4.在各类框架与语言中两种方式都使用。
3.OutOfMemoryError异常
	3.1java堆溢出：GC Roots到对象有之间有可达路径。堆内对象过多，但又有引用无法GC
	3.2虚拟机栈和本地方法栈溢出：在多线程时会导致内存溢出
	3.3方法区：CGLIB动态生成的Class加载到方法区可以能导致溢出
	3.3运行时常量池溢出：运行时有过多的常量String的intern
	3.4本机内存溢出：在操作I/O流的时候
4.垃圾回收和内存分配策略
	4.1.引用计数算法：存在循环引用，Java虚拟机未采用
	4.2.根搜索算法：jvm虚拟机采用此算法来实现gc
		1"GC Roots"到对象是否联通判定对象是否存货
		2.GC Roots对象包括：栈帧中的本地变量表的引用的对象，方法区中的类静态属性引用的对象，
			方法区中的常量引用的对象，本地方法栈中JNI的引用的对象
	4.3引用类型：强引用、软引用、弱引用、虚引用
		1.强引用：必需对象，示例，Object obj = new Object()，存在强引用，gc永远不会回收。
		2.软引用：非必需对象，在发送内存溢出异常之前，这些对象会列入回收范围并进行第二次回收。
		3.弱引用：非必需对象,被弱引用关联的对象只能生存到下一次垃圾收集发生之前。
		4.虚引用：不影响垃圾回收。无法通过虚引用获取对象示例，只用于GC时通知对象
 *4.4.GC回收：对象与GC Roots没有引用链时，GC会第一次标记对象，判断是否需要执行finalize()方法，
			如果没有必要或者已经执行了，则在下一次GC时清理对象内存。
	4.5方法区回收（Hotspot为永久代）
		1.在堆的新生代回收效率为70%~90%
		2.永久代的垃圾回收主要为：废弃常量和无用的类
		3.废弃常量：常量池没有被堆中的对象引用中的常量
		4.无用的类：
			1.堆中没有该类的实例
			2.加载该类的ClassLoader已经被回收
			3.该类的Class对象没有被任何地方引用，不能通过反射访问该类的方法
	4.6垃圾回收算法
		1.标记-清除算法
			1.标记处索引需要回收的对象，在标记完统一回收，存在效率问题和空间的问题，会有较多内存碎片，
				容易出现分配较大对象时内存不足，导致再次进行gc
		2.复制-清除算法
			1.虚拟机利用此算法回收新生代，新空间可分为Eden空间和To survivor空间和From Survivor空间
				Eden的大小与survivor比例为8:1；
			2.因为98%情况下的新生代对象是“朝令夕死”,回收时，把“存活”的对象复制到survivor空间，清理Eden空间
			3.如果新生代的对象剩余超过survivor容量(10%)，则需要依赖其他内存(老年代)
		3.标记-整理算法
			1.虚拟机利用此算法回收老年代
			2.与标记-清除算法一样先进行标记，然后把所有存活的对象向一端移动，再清理端边界以外的内存。
		4.虚拟机整体使用的算法是分代收集算法--根据对象的存活周期的不同将内存划分为几块（新生代、老年代），
			在不同年代采用适当的收集算法
	4.7垃圾收集器--七种
		1.Serial--jvm运行为client时默认的收集器
			1.曾经（jdk1.3）是新生代收集的唯一选择
			2.单线程收集器，一二百兆在几十到一百毫秒之间，简单高效
			3.运行回收垃圾时停止所有工作线程（stop the world）
			4.复制算法
		2.ParNew
			1.Serial收集器的多线程版本，几乎与Serial收集器相同
			2.默认为Server模式下的新生代收集器
			3.能配合CMS收集器使用
		3.Parallel Scavenge
			1.新生代收集器，复制算法，并行多线程，与ParNew类型
			2.设计的目标是：达到一个可控制的吞吐量。吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）
			3.停顿时间短适合与用户交互的程序，高吞吐量适合与后台运行的程序
			4.提供两个参数：-XX:MaxGCPauseMillis（最大垃圾收集停顿时间）和-XX:GCTimeRatio（吞吐量大小）
			5.-XX:+UseAdaptiveSizePolicy开关参数，打开后不需要手动执行新生代的大小（-Xmn）和Eden空间和Survivor空间的比例，以及晋升老年代对象年龄（-XX:PretenureSizeThreshold），采用GC自适应的调节策略（GCErgonomics）-----与ParNew收集器的重要区别
			6.不能配合CMS收集器使用
			7.运行回收垃圾时停止所有工作线程（stop the world）
		4.Serial Old收集器
			1.Serial收集器的老年代版本，单线程
			2.标记-整理算法，因为老年代没有备用内存。
			3.主要意思是：client模式下的默认算法
			4.在Server模式下，两大用途是：jdk1.5及以前版本中与Parallel Scavenge搭配使用，
				还有是作为CMS收集器的后备预案，在并发收集发送concurrent mode failure的时候使用
			5.运行回收垃圾时停止所有工作线程（stop the world）
		5.Parallel Old收集器
			1.Parallel Scanvenge的老年代版本，多线程
			2.标记-整理算法
			3.配合使用Parallel Scanvenge和Prarllel Old可以在高性能服务器上达到较高的吞吐量
			4.运行回收垃圾时停止所有工作线程（stop the world）
		6.CMS收集器（Concurrent Mark Sweep）
			1.设计目标：获取最短回收停顿时间的收集器
			2.重试服务的响应速度
			3.标记-清除算法
			4.回收过程分为四个部分：初始标记，并发标记，重新标记，并发清除
				1.初始标记：仍然是停止用户线程，标记GC Rots能直接关联到的对象，速度很快
				2.并发标记：与用户线程并发运行，进行GC Roots Tracing的过程
				3.重新标记阶段则是修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，
					这个阶段的停顿时间略长于初始标记
				4.并发清除：与用户线程并发运行
			5.三大显著缺点
				1.对CPU资源非常铭感，默认的线程数为（CPU数量+3）/4,在用户线程较低时占用cpu较多，增加用户应用的处理时间---采用i-CMS使用单线程模式下的CPU竞争策略。时间片轮转来减少对用户应用程序的影响，但是对加大GC的时间，deprecated不再提倡用户使用
				2.无法处理浮动垃圾，可以出现concurrent modl failure导致再一次Full GC
					1.并发清理阶段，用户还在产生垃圾，这部分垃圾需要等到下一次gc才能清理，成为浮动垃圾。
					2.因为是并发清理，所有需要预留空间给新的垃圾，默认为老年代内存的68%。可以设置-XX:CMSInitiatingOccupancyFraction来提供触发百分比。当运行期间出	现预留内存不足时会出现concurrent modl failure导致再一次Full Gc。采用后备方案Serial Old重新收集老年代内存。大大增加gc时间
					3.采用标记-清除算法，导致出现较多内存碎片，没有足够的连续空间分配给对象，可以采用-XX:+UseCMSCompactAtFullCollection开关参数，来进行一次碎片整理过程（此过程不能并发，需要停止用户线程），可以采用-XX:+CMSFullGCBeforeCompaction，进过多少次不压缩的full gc后来一次压缩的
			7.G1收集器
				1.jdk-u4后推出商用
				2.缩短用户线程的停顿时间，并发运行
				3.分代收集，收集范围包括新生代和老年代
					1.独立管理整个GC堆（新生代和老年代），不需要搭配使用，采用不同的方式处理不同代的对象
					2.保留分代概念，但是内存布局有很大差别，将整个堆划分为多个大小相等的独立区域（Region）。新生代和老年代不是		物理隔离
				4.整体采用标记-整理算法。局部（两个Region间）基于复制算法，不会产生内存碎片
				5.低停顿的实现高吞吐量-在明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒
				6.用于替换CMS
				7.运行过程分为：初始标记，并发标记，重新标记，筛选收回
					1.回收阶段采用复制算法，排序region的回收价值和成本（垃圾大小和预计时间）
					2.根据用户期望的GC停顿时间来制定回收计划，回收价值高的region，因为region内存较小，所有时间可控
					3.复制算法是从一个或多个region复制存活对象到堆上另一个空的region
				8.如何判定对象存活，因为存在不同区域对象之间的引用