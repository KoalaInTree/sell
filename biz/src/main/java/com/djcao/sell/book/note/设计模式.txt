设计原则：
	1.依赖倒转

	2.单一职责
	
	3.开闭原则

	4.迪米特法则：最少知识原则

	5.合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用类继承

设计模式：

	总的分类：
		1.创建型模式：简单工厂模式、工厂方法模式、抽象工厂模式、原型模式、建造者模式、单例模式
		2.结构型模式：代理模式、装饰者模式、外观模式、适配器模式、组合模式、桥接模式、享元模式
		3.行为型模式：策略模式、模版方法模式、观察者模式、状态模式、备忘录模式、迭代器模式、命令模式、责任链模式、中介者模式、解释器模式、访问者模式
			
	1.简单工厂模式：让工厂创建对象，包装对象的创建，让客户端无感知。

	2.策略模式：定义Content对象包装算法类，客户端只需要传入枚举值，在Content类内部实例化具体的实现算法类，客户端无需知晓何种算法，减低了算法与算法使用者的耦合度。

	3.装饰者模式：让核心类做核心的事，增加其他类为核心类增加功能

	4.代理模式：控制对象的方法权限

	5.工厂方法模式：优化简单工厂模式，符合开闭原则，对扩展开发，对修改关闭

	6.原型模式：实现Clone接口，使得对象可以复制。涉及浅复制和深复制，深复制可以使用JSON序列化和反序列化实现，也可以读取对象成二进制流复制。

	7.模版方法模式：继承和多态的使用。父类定义了主要的算法流程，骨架。留下细节部分交于子类实现，不同的子类实现不同的功能。

	8.外观模式：包装复杂的逻辑处理以及子系统调用，用Facade与负责的系统交互。

	9.建造者模式：对象创建的流程是稳定的，可以定义Build抽象接口定义好流程，让子类实现具体细节，然后再创建对象。

	10.观察者模式：MQ当中使用的模式，也称为发布/订阅模式，消费者获取消息有两种实现，推模型和拉模型；

	11.抽象工厂模式：当一个工厂需要维护多个版本的产品或者多个不同的产品的时候，就要考虑使用抽象工厂模式。

	12.状态模式：一个对象的行为取决于他的状态，并且在运行时才能判断就可以考虑使用状态模式；例如根据运行环境（测试，预发，生产）初始化不同的对外访问的client对象。减少条件分支语句的判断。

	13.适配器模式：需要调用第三方的接口或者复制最早期的类与接口的时候发现不匹配，可以用适配器模式来做中转。适配器模式不宜乱用，自己系统的接口应该是统一且可复用的。

	14.备忘录模式：需要记录运行时对象的状态，则在对象内部封装需要记录的Memento，保存于Caretaker，方便后续的状态恢复

	15.组合模式：定义Composite对象为树枝节点（或者根节点）拥有叶子节点（没有子节点）。需求中体现部分与整体层次的结构时，希望用户忽略组合对象与单个对象的不同，统一的使用结构中的所有对象时，就可以考虑使用组合模式了。

	16.迭代器模式：定义iterator接口，由各集合对象内部实现遍历的细节，对外统一使用迭代器遍历

	17.单例模式：重要的资源管理类和线程池需要定义为单例模式，懒汉式单例（双重校验+volatile---）(静态内部类)，饿汉式单例(定义为常量)。

	18.桥接模式:将抽象部分与它的实现部分分离，使它们都可以独立地变化

	19.命令模式:将请求封装成一个对象，从而使你可用不同的请求对客户就进行参数化；对请求排队或记录请求日志，以及支持可以撤销的操作。

	20.责任链模式：把多个对象依照顺序串成一条链，让请求可以被多个人处理，也可以被一个人处理。（多人同意才通过或者有一人处理就算通过）

	21.中介者模式:用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

	22.享元模式：运用共享技术有效地支持大量细粒度的对象

	23.解释器模式：给定一个语言，定义它的语法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子（正则表达式--应用）

	24.访问者模式：